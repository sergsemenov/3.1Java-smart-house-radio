## Цикломатическая сложность кода

1. Формула вычисления количества unit-тестов на основании значений, генерируемых JaCoCo

Плагин подсчитывает для каждого метода количество тестов в зависимости от количества ветвей (branches - "B") 
и точек принятия решения (decision points - "D") по формуле:
```
v = B - D + 1
```
Таким образом, в использованных методах имеем следующие значения:
* setCurrentChannel - 3 (3 - 1 + 1)
* nextChannel - 2 (2 - 1 + 1)
* previousChannel - 2 (2 - 1 + 1)

Кроме этого, getCurrentChannel и самому классу Radio() в целом JaCoCo присвоил сложность "1" и приплюсовал к Total.

Таким образом, метрика COMPLEXITY рекомендует использовать указанные количества unit-тестов для соответствующих 
методов.  

Полагаю, что в данной ситуации оценка весьма приблизительная, т.к. тесты при исполнении вызывают одновременно два 
метода (например, setCurrentChannel и nextChannel в одном тесте). Из этого следует, что, хотя код и покрывается 
тестами, однако сами тесты, вероятно, можно или даже следует проанализировать и/или переписать. Например, 
закомментировав два теста из 8, я все равно получил 100% покрытие по COMPLEXITY. Другим вариантом является использование
других метрик JaCoCO для оценки покрытия - BRANCHES, LINES и т.д. - вместо или в дополнение.
 
2.  Рекомендуемый порог цикломатической сложности кода

Многие разработчики накладывают на сложность кода по данной метрике ограничение в 10, а для кода, превышающего эту 
величину, требуют либо рефакторинга, либо обоснования превышения. В данной задачи Total Cxty = 9, что удовлетворяет 
пороговому значению. 

Сама задача размещена в отдельном [репозитории](https://github.com/sergsemenov/3.1Java-smart-house-radio-cyclomatic.git).